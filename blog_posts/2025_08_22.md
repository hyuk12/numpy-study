# 백엔드 개발자의 NumPy 첫걸음: 배열 생성부터 시각화까지

> **TL;DR**: 자바 백엔드 개발자가 AI/ML 전향을 위해 NumPy를 학습하며 배운 배열 생성 방법들과 시각화 기법을 정리했습니다. 체스보드 패턴부터 프랙탈까지, 코드와 함께 단계별로 설명합니다.

## 🎯 학습 배경

자바 베이스 백엔드 개발자에서 AI 로 변경하면서 마주하게되는 가장 첫번째 난관이 NumPy 인 것 같아서 통계전에 정리를 하기 위해 포스팅 합니다.<br>
두고두고 다시 보기 위한 기록용 블로그 포스팅 용입니다.

---

## 🏗️ 환경 설정

기본적으로 우분투 리눅스 24.04 버전을 사용하고 있습니다. <br>
우분투 리눅스에서 파이썬 설치와 가상환경 세팅에 대한 내용은 따로 다시 올릴 예정입니다.
```bash
# 가상환경 생성 및 활성화
python -m venv numpy-study
source numpy-study/bin/activate  # Windows: numpy-study\Scripts\activate

# 필수 패키지 설치
pip install numpy matplotlib seaborn jupyter
```

```python
# 라이브러리 임포트 및 기본 설정
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import ListedColormap, hsv_to_rgb

# 시각화 설정
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.size'] = 10

sns.set_style("whitegrid")
sns.set_palette("husl")
```

---

## 📊 1. NumPy 배열 생성의 다양한 방법

### 1.1 기본 배열 생성

```python
# 1차원 배열
arr_1d = np.array([1, 2, 3, 4, 5])
print(f"1D Array: {arr_1d}")
print(f"Shape: {arr_1d.shape}, Type: {arr_1d.dtype}")

# 2차원 배열 (행렬)
arr_2d = np.array([[1, 2, 3], 
                   [4, 5, 6]])
print(f"2D Array:\n{arr_2d}")
print(f"Shape: {arr_2d.shape}")

# 3차원 배열 (텐서)
arr_3d = np.array([[[1, 2], [3, 4]], 
                   [[5, 6], [7, 8]]])
print(f"3D Array Shape: {arr_3d.shape}")
```

**출력 결과:**
```
1D Array: [1 2 3 4 5]
Shape: (5,), Type: int64
2D Array:
[[1 2 3]
 [4 5 6]]
Shape: (2, 3)
3D Array Shape: (2, 2, 2)
```

### 1.2 특수 배열 생성

```python
# 영행렬과 일행렬
zeros_2d = np.zeros((3, 4))
ones_2d = np.ones((2, 5))
full_array = np.full((3, 3), 7)

print("Zeros Array:")
print(zeros_2d)
print("\nOnes Array:")
print(ones_2d)
print(f"\nFull Array (filled with 7):\n{full_array}")

# 단위행렬
identity_matrix = np.eye(4)
print(f"\nIdentity Matrix:\n{identity_matrix}")
```

### 1.3 범위 기반 생성

```python
# arange: Python range와 유사
basic_range = np.arange(10)
custom_range = np.arange(2, 20, 3)
float_range = np.arange(0, 1, 0.1)

print(f"Basic range: {basic_range}")
print(f"Custom range: {custom_range}")
print(f"Float range: {float_range}")

# linspace: 균등하게 분할
linear_space = np.linspace(0, 10, 5)
print(f"Linear space: {linear_space}")

# logspace: 로그 스케일
log_space = np.logspace(0, 3, 4)
print(f"Log space: {log_space}")
```

**출력 결과:**
```
Basic range: [0 1 2 3 4 5 6 7 8 9]
Custom range: [ 2  5  8 11 14 17]
Float range: [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]
Linear space: [ 0.   2.5  5.   7.5 10. ]
Log space: [   1.   10.  100. 1000.]
```

---

## 🎨 2. 패턴 생성과 시각화

### 2.1 체스보드 패턴

가장 기본적이면서도 NumPy의 인덱싱을 이해하기 좋은 예제입니다.

```python
def create_chessboard(size=8):
    """체스보드 패턴 생성"""
    chessboard = np.zeros((size, size))
    chessboard[1::2, ::2] = 1  # 홀수 행, 짝수 열
    chessboard[::2, 1::2] = 1  # 짝수 행, 홀수 열
    return chessboard

# 체스보드 생성 및 시각화
chess = create_chessboard(8)
print("8x8 Chessboard:")
print(chess)

# 시각화
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# 흑백 체스보드
axes[0].imshow(chess, cmap='gray', interpolation='nearest')
axes[0].set_title('Black & White Chessboard')
axes[0].grid(True, color='red', linewidth=0.5, alpha=0.3)

# 컬러 체스보드
axes[1].imshow(chess, cmap='RdBu', interpolation='nearest')
axes[1].set_title('Colored Chessboard')

# 큰 체스보드
big_chess = create_chessboard(16)
axes[2].imshow(big_chess, cmap='viridis', interpolation='nearest')
axes[2].set_title('16x16 Chessboard')

plt.tight_layout()
plt.show()
```

### 2.2 RGB 색상 패턴

RGB 채널을 개별적으로 조작해서 다양한 색상 패턴을 만들어보겠습니다.

```python
def create_rgb_patterns():
    """RGB 채널별 패턴 생성"""
    size = 100
    
    # RGB 이미지 생성
    rgb_image = np.zeros((size, size, 3))
    
    # R 채널: 수평 그라디언트
    rgb_image[:, :, 0] = np.linspace(0, 1, size)
    
    # G 채널: 수직 그라디언트
    rgb_image[:, :, 1] = np.linspace(0, 1, size).reshape(-1, 1)
    
    # B 채널: 대각선 그라디언트
    x, y = np.meshgrid(np.linspace(0, 1, size), np.linspace(0, 1, size))
    rgb_image[:, :, 2] = (x + y) / 2
    
    return rgb_image

# RGB 패턴 시각화
rgb_pattern = create_rgb_patterns()
fig, axes = plt.subplots(2, 4, figsize=(16, 8))

# 전체 RGB 이미지
axes[0, 0].imshow(rgb_pattern)
axes[0, 0].set_title('RGB Combined')
axes[0, 0].axis('off')

# 각 채널별 시각화
channels = ['R', 'G', 'B']
colors = ['Reds', 'Greens', 'Blues']

for i in range(3):
    axes[0, i+1].imshow(rgb_pattern[:, :, i], cmap=colors[i])
    axes[0, i+1].set_title(f'{channels[i]} Channel')
    axes[0, i+1].axis('off')

# HSV 색상 공간
h = np.linspace(0, 1, 100)
s = np.linspace(0, 1, 100)
H, S = np.meshgrid(h, s)
V = np.ones_like(H)
hsv = np.stack([H, S, V], axis=2)
rgb_from_hsv = hsv_to_rgb(hsv)

axes[1, 0].imshow(rgb_from_hsv)
axes[1, 0].set_title('HSV Color Wheel')
axes[1, 0].axis('off')

# 원형 색상환
angles = np.linspace(0, 2*np.pi, 360)
radius = np.linspace(0, 1, 100)
A, R = np.meshgrid(angles, radius)

H_wheel = A / (2 * np.pi)
S_wheel = R
V_wheel = np.ones_like(H_wheel)
hsv_wheel = np.stack([H_wheel, S_wheel, V_wheel], axis=2)
rgb_wheel = hsv_to_rgb(hsv_wheel)

axes[1, 1].imshow(rgb_wheel, extent=[-1, 1, -1, 1])
axes[1, 1].set_title('Circular Color Wheel')
axes[1, 1].axis('off')

# 색상 스펙트럼
spectrum = np.linspace(0, 1, 256).reshape(1, -1)
spectrum_rgb = plt.cm.rainbow(spectrum)
axes[1, 2].imshow(spectrum_rgb, aspect='auto')
axes[1, 2].set_title('Color Spectrum')
axes[1, 2].axis('off')

# 빈 subplot 숨기기
axes[1, 3].axis('off')

plt.tight_layout()
plt.show()
```

### 2.3 수학적 패턴

삼각함수와 기하학적 함수를 사용해서 아름다운 패턴을 만들어보겠습니다.

```python
def create_wave_patterns():
    """삼각함수 기반 패턴 생성"""
    size = 200
    x = np.linspace(-4*np.pi, 4*np.pi, size)
    y = np.linspace(-4*np.pi, 4*np.pi, size)
    X, Y = np.meshgrid(x, y)
    
    patterns = {
        'Sine Wave': np.sin(np.sqrt(X**2 + Y**2)),
        'Cosine Interference': np.cos(X) * np.cos(Y),
        'Ripple Effect': np.sin(np.sqrt(X**2 + Y**2)) / (np.sqrt(X**2 + Y**2) + 1),
        'Checker Sine': np.sin(X) * np.sin(Y),
        'Spiral Wave': np.sin(X * np.cos(0.5) + Y * np.sin(0.5)),
        'Moire Pattern': np.sin(10*X) * np.sin(10.1*Y)
    }
    
    return patterns

# 파동 패턴 시각화
patterns = create_wave_patterns()

fig, axes = plt.subplots(2, 3, figsize=(18, 12))
axes = axes.flatten()

for i, (name, pattern) in enumerate(patterns.items()):
    im = axes[i].imshow(pattern, cmap='RdBu', extent=[-4*np.pi, 4*np.pi, -4*np.pi, 4*np.pi])
    axes[i].set_title(name)
    axes[i].axis('off')

plt.tight_layout()
plt.suptitle('Mathematical Patterns with NumPy', fontsize=16, y=1.02)
plt.show()
```

---

## 🌀 3. 고급 패턴: 프랙탈

NumPy의 진정한 힘을 보여주는 프랙탈 생성입니다.

```python
def mandelbrot_set(width, height, max_iter=100):
    """만델브로트 집합 생성"""
    # 복소평면 설정
    x_min, x_max = -2.5, 1.5
    y_min, y_max = -2, 2
    
    # 좌표 생성
    x = np.linspace(x_min, x_max, width)
    y = np.linspace(y_min, y_max, height)
    X, Y = np.meshgrid(x, y)
    C = X + 1j * Y
    
    # 만델브로트 계산
    Z = np.zeros_like(C)
    iterations = np.zeros(C.shape, dtype=int)
    
    for i in range(max_iter):
        mask = np.abs(Z) <= 2
        Z[mask] = Z[mask]**2 + C[mask]
        iterations[mask] = i
    
    return iterations

# 만델브로트 집합 시각화
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

resolutions = [200, 400, 600]
for i, res in enumerate(resolutions):
    mandelbrot = mandelbrot_set(res, res, max_iter=50)
    im = axes[i].imshow(mandelbrot, cmap='hot', extent=[-2.5, 1.5, -2, 2])
    axes[i].set_title(f'Mandelbrot Set ({res}x{res})')
    axes[i].axis('off')

plt.tight_layout()
plt.show()
```

---

## 📈 4. 데이터 분석 시각화

실제 데이터 분석에서 사용할 수 있는 시각화 예제입니다.

```python
# 랜덤 데이터 생성 및 시각화
np.random.seed(42)
n_samples = 1000

# 다양한 확률분포
distributions = {
    'Normal': np.random.normal(0, 1, n_samples),
    'Exponential': np.random.exponential(1, n_samples),
    'Uniform': np.random.uniform(-3, 3, n_samples),
    'Gamma': np.random.gamma(2, 2, n_samples)
}

fig, axes = plt.subplots(2, 2, figsize=(15, 10))
axes = axes.flatten()

for i, (name, data) in enumerate(distributions.items()):
    # 히스토그램
    axes[i].hist(data, bins=50, alpha=0.7, density=True, color=f'C{i}')
    axes[i].set_title(f'{name} Distribution')
    axes[i].set_ylabel('Density')
    axes[i].grid(True, alpha=0.3)
    
    # 통계량 표시
    mean = np.mean(data)
    std = np.std(data)
    axes[i].axvline(mean, color='red', linestyle='--', 
                   label=f'Mean: {mean:.2f}')
    axes[i].axvline(mean + std, color='orange', linestyle='--', alpha=0.7)
    axes[i].axvline(mean - std, color='orange', linestyle='--', alpha=0.7)
    axes[i].legend()

plt.tight_layout()
plt.show()

# 2D 데이터 분석
x = np.random.randn(1000)
y = 2 * x + np.random.randn(1000) * 0.5

fig, axes = plt.subplots(1, 2, figsize=(15, 6))

# 산점도
axes[0].scatter(x, y, alpha=0.6, s=30)
axes[0].set_title('Scatter Plot')
axes[0].set_xlabel('X values')
axes[0].set_ylabel('Y values')
axes[0].grid(True, alpha=0.3)

# 2D 히스토그램 (히트맵)
h, xedges, yedges = np.histogram2d(x, y, bins=30)
im = axes[1].imshow(h.T, origin='lower', cmap='Blues',
                   extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
axes[1].set_title('2D Histogram')
axes[1].set_xlabel('X values')
axes[1].set_ylabel('Y values')
plt.colorbar(im, ax=axes[1])

plt.tight_layout()
plt.show()

print(f"Correlation coefficient: {np.corrcoef(x, y)[0,1]:.3f}")
```

---

## 💡 5. 백엔드 개발자 관점에서의 인사이트

### 메모리 효율성 비교

```python
import sys
import time

# Python 리스트 vs NumPy 배열
size = 1000000

# 메모리 사용량 비교
python_list = [0] * size
numpy_array = np.zeros(size)

print(f"Python List Memory: {sys.getsizeof(python_list):,} bytes")
print(f"NumPy Array Memory: {numpy_array.nbytes:,} bytes")
print(f"Memory Efficiency: {sys.getsizeof(python_list) / numpy_array.nbytes:.1f}x")

# 성능 비교
def python_sum_squares(lst):
    return sum(x**2 for x in lst)

def numpy_sum_squares(arr):
    return np.sum(arr**2)

# 테스트 데이터
test_list = list(range(100000))
test_array = np.arange(100000)

# Python 리스트 성능
start = time.time()
python_result = python_sum_squares(test_list)
python_time = time.time() - start

# NumPy 배열 성능
start = time.time()
numpy_result = numpy_sum_squares(test_array)
numpy_time = time.time() - start

print(f"\nPerformance Comparison:")
print(f"Python List Time: {python_time:.4f} seconds")
print(f"NumPy Array Time: {numpy_time:.4f} seconds")
print(f"Speed Improvement: {python_time / numpy_time:.1f}x faster")
```

### 실무 적용 아이디어

```python
# 1. 로그 데이터 분석 시뮬레이션
def simulate_server_logs():
    """서버 로그 데이터 시뮬레이션"""
    # 24시간 동안 1분마다 기록된 응답시간 (ms)
    hours = np.arange(24)
    response_times = []
    
    for hour in hours:
        # 업무시간(9-18시)에는 응답시간이 높아짐
        if 9 <= hour <= 18:
            base_time = 200 + hour * 10
        else:
            base_time = 100
        
        # 60분간의 데이터 (노이즈 포함)
        hourly_data = np.random.normal(base_time, 30, 60)
        response_times.extend(hourly_data)
    
    return np.array(response_times)

# 로그 데이터 생성 및 분석
log_data = simulate_server_logs()
time_axis = np.arange(len(log_data)) / 60  # 시간 단위 변환

# 시각화
fig, axes = plt.subplots(2, 2, figsize=(16, 10))

# 전체 추이
axes[0, 0].plot(time_axis, log_data, alpha=0.7, linewidth=0.5)
axes[0, 0].set_title('Server Response Time (24 hours)')
axes[0, 0].set_xlabel('Time (hours)')
axes[0, 0].set_ylabel('Response Time (ms)')
axes[0, 0].grid(True, alpha=0.3)

# 히스토그램
axes[0, 1].hist(log_data, bins=50, alpha=0.7, color='skyblue', edgecolor='black')
axes[0, 1].set_title('Response Time Distribution')
axes[0, 1].set_xlabel('Response Time (ms)')
axes[0, 1].set_ylabel('Frequency')
axes[0, 1].grid(True, alpha=0.3)

# 시간대별 평균
hourly_avg = np.array([np.mean(log_data[i*60:(i+1)*60]) for i in range(24)])
axes[1, 0].bar(range(24), hourly_avg, color='lightcoral', alpha=0.7)
axes[1, 0].set_title('Average Response Time by Hour')
axes[1, 0].set_xlabel('Hour of Day')
axes[1, 0].set_ylabel('Avg Response Time (ms)')
axes[1, 0].grid(True, alpha=0.3)

# 이동평균 (트렌드 분석)
window_size = 60  # 1시간 윈도우
moving_avg = np.convolve(log_data, np.ones(window_size)/window_size, mode='valid')
axes[1, 1].plot(time_axis[window_size-1:], moving_avg, color='red', linewidth=2)
axes[1, 1].set_title('1-Hour Moving Average')
axes[1, 1].set_xlabel('Time (hours)')
axes[1, 1].set_ylabel('Response Time (ms)')
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# 통계 분석
print("📊 Server Performance Analysis:")
print(f"Average Response Time: {np.mean(log_data):.1f} ms")
print(f"95th Percentile: {np.percentile(log_data, 95):.1f} ms")
print(f"Peak Hour: {np.argmax(hourly_avg):02d}:00")
print(f"Best Hour: {np.argmin(hourly_avg):02d}:00")
```

---

## 🎯 배운 점과 다음 단계

### 핵심 인사이트

1. **메모리 효율성**: NumPy 배열은 Python 리스트보다 메모리 사용량이 현저히 적음
2. **성능**: 벡터화 연산으로 10-100배 빠른 계산 가능
3. **시각화의 힘**: 복잡한 수학적 개념도 그래프로 보면 직관적으로 이해 가능
4. **실무 활용성**: 서버 모니터링, 로그 분석 등 백엔드 업무에도 적용 가능

### 어려웠던 점

- **브로드캐스팅 개념**: 다차원 배열 간의 연산 규칙 이해
- **인덱싱 복잡성**: 다차원 배열에서의 슬라이싱과 불린 인덱싱
- **메모리 레이아웃**: View vs Copy의 차이점과 성능에 미치는 영향

### 다음 학습 계획

1. **Pandas 마스터**: DataFrame을 활용한 실제 데이터 분석
2. **Scikit-learn 기초**: 머신러닝 알고리즘 적용
3. **캐글 도전**: 실전 데이터 사이언스 경험
4. **Deep Learning**: PyTorch/TensorFlow로 신경망 구현

---

## 🔗 관련 링크

- **GitHub 저장소**: [numpy-study](https://github.com/hyuk12/numpy-study)
- **Jupyter 노트북**: [01_numpy_basics.ipynb](https://github.com/hyuk12/numpy-study/blob/main/notebooks/01_numpy_basics.ipynb)
- **다음 포스팅 예고**: "Pandas 완전 정복: DataFrame으로 실제 데이터 분석하기"

---

## 💬 마무리

AI 부트캠프를 시작하면서 얻은 인사이트가 캐글을 통해 실제 코드를 구성하고 각종 대회를 나가면서 학습 하는 것이 좋을 것 같아서 <br>
NumPy 부터 Pandas 등 학습을 진행하고 캐글을 도전해볼 예정입니다.

아무래도 자바 기반의 백엔드 실무를 겪었지만, 파이썬이라는 언어를 통해 통계나 시각화 수치 계산등을 하는 것이 익숙하지는 않아서 계속 보면서 학습을 이어나가야 할 것 같습니다.

---

**작성일**: 2025-08-22  
**태그**: `#NumPy` `#Python` `#DataScience` `#MachineLearning` `#백엔드개발자` `#AI전향` `#시각화`

*이 글이 도움이 되셨다면 👍 공감과 댓글로 피드백 부탁드립니다!*