# ë°±ì—”ë“œ ê°œë°œìì˜ NumPy ì²«ê±¸ìŒ: ë°°ì—´ ìƒì„±ë¶€í„° ì‹œê°í™”ê¹Œì§€

> **TL;DR**: ìë°” ë°±ì—”ë“œ ê°œë°œìê°€ AI/ML ì „í–¥ì„ ìœ„í•´ NumPyë¥¼ í•™ìŠµí•˜ë©° ë°°ìš´ ë°°ì—´ ìƒì„± ë°©ë²•ë“¤ê³¼ ì‹œê°í™” ê¸°ë²•ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤. ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ë¶€í„° í”„ë™íƒˆê¹Œì§€, ì½”ë“œì™€ í•¨ê»˜ ë‹¨ê³„ë³„ë¡œ ì„¤ëª…í•©ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ë°°ê²½

ìë°” ë² ì´ìŠ¤ ë°±ì—”ë“œ ê°œë°œìì—ì„œ AI ë¡œ ë³€ê²½í•˜ë©´ì„œ ë§ˆì£¼í•˜ê²Œë˜ëŠ” ê°€ì¥ ì²«ë²ˆì§¸ ë‚œê´€ì´ NumPy ì¸ ê²ƒ ê°™ì•„ì„œ í†µê³„ì „ì— ì •ë¦¬ë¥¼ í•˜ê¸° ìœ„í•´ í¬ìŠ¤íŒ… í•©ë‹ˆë‹¤.<br>
ë‘ê³ ë‘ê³  ë‹¤ì‹œ ë³´ê¸° ìœ„í•œ ê¸°ë¡ìš© ë¸”ë¡œê·¸ í¬ìŠ¤íŒ… ìš©ì…ë‹ˆë‹¤.

---

## ğŸ—ï¸ í™˜ê²½ ì„¤ì •

ê¸°ë³¸ì ìœ¼ë¡œ ìš°ë¶„íˆ¬ ë¦¬ëˆ…ìŠ¤ 24.04 ë²„ì „ì„ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤. <br>
ìš°ë¶„íˆ¬ ë¦¬ëˆ…ìŠ¤ì—ì„œ íŒŒì´ì¬ ì„¤ì¹˜ì™€ ê°€ìƒí™˜ê²½ ì„¸íŒ…ì— ëŒ€í•œ ë‚´ìš©ì€ ë”°ë¡œ ë‹¤ì‹œ ì˜¬ë¦´ ì˜ˆì •ì…ë‹ˆë‹¤.
```bash
# ê°€ìƒí™˜ê²½ ìƒì„± ë° í™œì„±í™”
python -m venv numpy-study
source numpy-study/bin/activate  # Windows: numpy-study\Scripts\activate

# í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜
pip install numpy matplotlib seaborn jupyter
```

```python
# ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„í¬íŠ¸ ë° ê¸°ë³¸ ì„¤ì •
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import ListedColormap, hsv_to_rgb

# ì‹œê°í™” ì„¤ì •
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.size'] = 10

sns.set_style("whitegrid")
sns.set_palette("husl")
```

---

## ğŸ“Š 1. NumPy ë°°ì—´ ìƒì„±ì˜ ë‹¤ì–‘í•œ ë°©ë²•

### 1.1 ê¸°ë³¸ ë°°ì—´ ìƒì„±

```python
# 1ì°¨ì› ë°°ì—´
arr_1d = np.array([1, 2, 3, 4, 5])
print(f"1D Array: {arr_1d}")
print(f"Shape: {arr_1d.shape}, Type: {arr_1d.dtype}")

# 2ì°¨ì› ë°°ì—´ (í–‰ë ¬)
arr_2d = np.array([[1, 2, 3], 
                   [4, 5, 6]])
print(f"2D Array:\n{arr_2d}")
print(f"Shape: {arr_2d.shape}")

# 3ì°¨ì› ë°°ì—´ (í…ì„œ)
arr_3d = np.array([[[1, 2], [3, 4]], 
                   [[5, 6], [7, 8]]])
print(f"3D Array Shape: {arr_3d.shape}")
```

**ì¶œë ¥ ê²°ê³¼:**
```
1D Array: [1 2 3 4 5]
Shape: (5,), Type: int64
2D Array:
[[1 2 3]
 [4 5 6]]
Shape: (2, 3)
3D Array Shape: (2, 2, 2)
```

### 1.2 íŠ¹ìˆ˜ ë°°ì—´ ìƒì„±

```python
# ì˜í–‰ë ¬ê³¼ ì¼í–‰ë ¬
zeros_2d = np.zeros((3, 4))
ones_2d = np.ones((2, 5))
full_array = np.full((3, 3), 7)

print("Zeros Array:")
print(zeros_2d)
print("\nOnes Array:")
print(ones_2d)
print(f"\nFull Array (filled with 7):\n{full_array}")

# ë‹¨ìœ„í–‰ë ¬
identity_matrix = np.eye(4)
print(f"\nIdentity Matrix:\n{identity_matrix}")
```

### 1.3 ë²”ìœ„ ê¸°ë°˜ ìƒì„±

```python
# arange: Python rangeì™€ ìœ ì‚¬
basic_range = np.arange(10)
custom_range = np.arange(2, 20, 3)
float_range = np.arange(0, 1, 0.1)

print(f"Basic range: {basic_range}")
print(f"Custom range: {custom_range}")
print(f"Float range: {float_range}")

# linspace: ê· ë“±í•˜ê²Œ ë¶„í• 
linear_space = np.linspace(0, 10, 5)
print(f"Linear space: {linear_space}")

# logspace: ë¡œê·¸ ìŠ¤ì¼€ì¼
log_space = np.logspace(0, 3, 4)
print(f"Log space: {log_space}")
```

**ì¶œë ¥ ê²°ê³¼:**
```
Basic range: [0 1 2 3 4 5 6 7 8 9]
Custom range: [ 2  5  8 11 14 17]
Float range: [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]
Linear space: [ 0.   2.5  5.   7.5 10. ]
Log space: [   1.   10.  100. 1000.]
```

---

## ğŸ¨ 2. íŒ¨í„´ ìƒì„±ê³¼ ì‹œê°í™”

### 2.1 ì²´ìŠ¤ë³´ë“œ íŒ¨í„´

ê°€ì¥ ê¸°ë³¸ì ì´ë©´ì„œë„ NumPyì˜ ì¸ë±ì‹±ì„ ì´í•´í•˜ê¸° ì¢‹ì€ ì˜ˆì œì…ë‹ˆë‹¤.

```python
def create_chessboard(size=8):
    """ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ ìƒì„±"""
    chessboard = np.zeros((size, size))
    chessboard[1::2, ::2] = 1  # í™€ìˆ˜ í–‰, ì§ìˆ˜ ì—´
    chessboard[::2, 1::2] = 1  # ì§ìˆ˜ í–‰, í™€ìˆ˜ ì—´
    return chessboard

# ì²´ìŠ¤ë³´ë“œ ìƒì„± ë° ì‹œê°í™”
chess = create_chessboard(8)
print("8x8 Chessboard:")
print(chess)

# ì‹œê°í™”
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# í‘ë°± ì²´ìŠ¤ë³´ë“œ
axes[0].imshow(chess, cmap='gray', interpolation='nearest')
axes[0].set_title('Black & White Chessboard')
axes[0].grid(True, color='red', linewidth=0.5, alpha=0.3)

# ì»¬ëŸ¬ ì²´ìŠ¤ë³´ë“œ
axes[1].imshow(chess, cmap='RdBu', interpolation='nearest')
axes[1].set_title('Colored Chessboard')

# í° ì²´ìŠ¤ë³´ë“œ
big_chess = create_chessboard(16)
axes[2].imshow(big_chess, cmap='viridis', interpolation='nearest')
axes[2].set_title('16x16 Chessboard')

plt.tight_layout()
plt.show()
```

### 2.2 RGB ìƒ‰ìƒ íŒ¨í„´

RGB ì±„ë„ì„ ê°œë³„ì ìœ¼ë¡œ ì¡°ì‘í•´ì„œ ë‹¤ì–‘í•œ ìƒ‰ìƒ íŒ¨í„´ì„ ë§Œë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

```python
def create_rgb_patterns():
    """RGB ì±„ë„ë³„ íŒ¨í„´ ìƒì„±"""
    size = 100
    
    # RGB ì´ë¯¸ì§€ ìƒì„±
    rgb_image = np.zeros((size, size, 3))
    
    # R ì±„ë„: ìˆ˜í‰ ê·¸ë¼ë””ì–¸íŠ¸
    rgb_image[:, :, 0] = np.linspace(0, 1, size)
    
    # G ì±„ë„: ìˆ˜ì§ ê·¸ë¼ë””ì–¸íŠ¸
    rgb_image[:, :, 1] = np.linspace(0, 1, size).reshape(-1, 1)
    
    # B ì±„ë„: ëŒ€ê°ì„  ê·¸ë¼ë””ì–¸íŠ¸
    x, y = np.meshgrid(np.linspace(0, 1, size), np.linspace(0, 1, size))
    rgb_image[:, :, 2] = (x + y) / 2
    
    return rgb_image

# RGB íŒ¨í„´ ì‹œê°í™”
rgb_pattern = create_rgb_patterns()
fig, axes = plt.subplots(2, 4, figsize=(16, 8))

# ì „ì²´ RGB ì´ë¯¸ì§€
axes[0, 0].imshow(rgb_pattern)
axes[0, 0].set_title('RGB Combined')
axes[0, 0].axis('off')

# ê° ì±„ë„ë³„ ì‹œê°í™”
channels = ['R', 'G', 'B']
colors = ['Reds', 'Greens', 'Blues']

for i in range(3):
    axes[0, i+1].imshow(rgb_pattern[:, :, i], cmap=colors[i])
    axes[0, i+1].set_title(f'{channels[i]} Channel')
    axes[0, i+1].axis('off')

# HSV ìƒ‰ìƒ ê³µê°„
h = np.linspace(0, 1, 100)
s = np.linspace(0, 1, 100)
H, S = np.meshgrid(h, s)
V = np.ones_like(H)
hsv = np.stack([H, S, V], axis=2)
rgb_from_hsv = hsv_to_rgb(hsv)

axes[1, 0].imshow(rgb_from_hsv)
axes[1, 0].set_title('HSV Color Wheel')
axes[1, 0].axis('off')

# ì›í˜• ìƒ‰ìƒí™˜
angles = np.linspace(0, 2*np.pi, 360)
radius = np.linspace(0, 1, 100)
A, R = np.meshgrid(angles, radius)

H_wheel = A / (2 * np.pi)
S_wheel = R
V_wheel = np.ones_like(H_wheel)
hsv_wheel = np.stack([H_wheel, S_wheel, V_wheel], axis=2)
rgb_wheel = hsv_to_rgb(hsv_wheel)

axes[1, 1].imshow(rgb_wheel, extent=[-1, 1, -1, 1])
axes[1, 1].set_title('Circular Color Wheel')
axes[1, 1].axis('off')

# ìƒ‰ìƒ ìŠ¤í™íŠ¸ëŸ¼
spectrum = np.linspace(0, 1, 256).reshape(1, -1)
spectrum_rgb = plt.cm.rainbow(spectrum)
axes[1, 2].imshow(spectrum_rgb, aspect='auto')
axes[1, 2].set_title('Color Spectrum')
axes[1, 2].axis('off')

# ë¹ˆ subplot ìˆ¨ê¸°ê¸°
axes[1, 3].axis('off')

plt.tight_layout()
plt.show()
```

### 2.3 ìˆ˜í•™ì  íŒ¨í„´

ì‚¼ê°í•¨ìˆ˜ì™€ ê¸°í•˜í•™ì  í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ì•„ë¦„ë‹¤ìš´ íŒ¨í„´ì„ ë§Œë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

```python
def create_wave_patterns():
    """ì‚¼ê°í•¨ìˆ˜ ê¸°ë°˜ íŒ¨í„´ ìƒì„±"""
    size = 200
    x = np.linspace(-4*np.pi, 4*np.pi, size)
    y = np.linspace(-4*np.pi, 4*np.pi, size)
    X, Y = np.meshgrid(x, y)
    
    patterns = {
        'Sine Wave': np.sin(np.sqrt(X**2 + Y**2)),
        'Cosine Interference': np.cos(X) * np.cos(Y),
        'Ripple Effect': np.sin(np.sqrt(X**2 + Y**2)) / (np.sqrt(X**2 + Y**2) + 1),
        'Checker Sine': np.sin(X) * np.sin(Y),
        'Spiral Wave': np.sin(X * np.cos(0.5) + Y * np.sin(0.5)),
        'Moire Pattern': np.sin(10*X) * np.sin(10.1*Y)
    }
    
    return patterns

# íŒŒë™ íŒ¨í„´ ì‹œê°í™”
patterns = create_wave_patterns()

fig, axes = plt.subplots(2, 3, figsize=(18, 12))
axes = axes.flatten()

for i, (name, pattern) in enumerate(patterns.items()):
    im = axes[i].imshow(pattern, cmap='RdBu', extent=[-4*np.pi, 4*np.pi, -4*np.pi, 4*np.pi])
    axes[i].set_title(name)
    axes[i].axis('off')

plt.tight_layout()
plt.suptitle('Mathematical Patterns with NumPy', fontsize=16, y=1.02)
plt.show()
```

---

## ğŸŒ€ 3. ê³ ê¸‰ íŒ¨í„´: í”„ë™íƒˆ

NumPyì˜ ì§„ì •í•œ í˜ì„ ë³´ì—¬ì£¼ëŠ” í”„ë™íƒˆ ìƒì„±ì…ë‹ˆë‹¤.

```python
def mandelbrot_set(width, height, max_iter=100):
    """ë§Œë¸ë¸Œë¡œíŠ¸ ì§‘í•© ìƒì„±"""
    # ë³µì†Œí‰ë©´ ì„¤ì •
    x_min, x_max = -2.5, 1.5
    y_min, y_max = -2, 2
    
    # ì¢Œí‘œ ìƒì„±
    x = np.linspace(x_min, x_max, width)
    y = np.linspace(y_min, y_max, height)
    X, Y = np.meshgrid(x, y)
    C = X + 1j * Y
    
    # ë§Œë¸ë¸Œë¡œíŠ¸ ê³„ì‚°
    Z = np.zeros_like(C)
    iterations = np.zeros(C.shape, dtype=int)
    
    for i in range(max_iter):
        mask = np.abs(Z) <= 2
        Z[mask] = Z[mask]**2 + C[mask]
        iterations[mask] = i
    
    return iterations

# ë§Œë¸ë¸Œë¡œíŠ¸ ì§‘í•© ì‹œê°í™”
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

resolutions = [200, 400, 600]
for i, res in enumerate(resolutions):
    mandelbrot = mandelbrot_set(res, res, max_iter=50)
    im = axes[i].imshow(mandelbrot, cmap='hot', extent=[-2.5, 1.5, -2, 2])
    axes[i].set_title(f'Mandelbrot Set ({res}x{res})')
    axes[i].axis('off')

plt.tight_layout()
plt.show()
```

---

## ğŸ“ˆ 4. ë°ì´í„° ë¶„ì„ ì‹œê°í™”

ì‹¤ì œ ë°ì´í„° ë¶„ì„ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì‹œê°í™” ì˜ˆì œì…ë‹ˆë‹¤.

```python
# ëœë¤ ë°ì´í„° ìƒì„± ë° ì‹œê°í™”
np.random.seed(42)
n_samples = 1000

# ë‹¤ì–‘í•œ í™•ë¥ ë¶„í¬
distributions = {
    'Normal': np.random.normal(0, 1, n_samples),
    'Exponential': np.random.exponential(1, n_samples),
    'Uniform': np.random.uniform(-3, 3, n_samples),
    'Gamma': np.random.gamma(2, 2, n_samples)
}

fig, axes = plt.subplots(2, 2, figsize=(15, 10))
axes = axes.flatten()

for i, (name, data) in enumerate(distributions.items()):
    # íˆìŠ¤í† ê·¸ë¨
    axes[i].hist(data, bins=50, alpha=0.7, density=True, color=f'C{i}')
    axes[i].set_title(f'{name} Distribution')
    axes[i].set_ylabel('Density')
    axes[i].grid(True, alpha=0.3)
    
    # í†µê³„ëŸ‰ í‘œì‹œ
    mean = np.mean(data)
    std = np.std(data)
    axes[i].axvline(mean, color='red', linestyle='--', 
                   label=f'Mean: {mean:.2f}')
    axes[i].axvline(mean + std, color='orange', linestyle='--', alpha=0.7)
    axes[i].axvline(mean - std, color='orange', linestyle='--', alpha=0.7)
    axes[i].legend()

plt.tight_layout()
plt.show()

# 2D ë°ì´í„° ë¶„ì„
x = np.random.randn(1000)
y = 2 * x + np.random.randn(1000) * 0.5

fig, axes = plt.subplots(1, 2, figsize=(15, 6))

# ì‚°ì ë„
axes[0].scatter(x, y, alpha=0.6, s=30)
axes[0].set_title('Scatter Plot')
axes[0].set_xlabel('X values')
axes[0].set_ylabel('Y values')
axes[0].grid(True, alpha=0.3)

# 2D íˆìŠ¤í† ê·¸ë¨ (íˆíŠ¸ë§µ)
h, xedges, yedges = np.histogram2d(x, y, bins=30)
im = axes[1].imshow(h.T, origin='lower', cmap='Blues',
                   extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
axes[1].set_title('2D Histogram')
axes[1].set_xlabel('X values')
axes[1].set_ylabel('Y values')
plt.colorbar(im, ax=axes[1])

plt.tight_layout()
plt.show()

print(f"Correlation coefficient: {np.corrcoef(x, y)[0,1]:.3f}")
```

---

## ğŸ’¡ 5. ë°±ì—”ë“œ ê°œë°œì ê´€ì ì—ì„œì˜ ì¸ì‚¬ì´íŠ¸

### ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ë¹„êµ

```python
import sys
import time

# Python ë¦¬ìŠ¤íŠ¸ vs NumPy ë°°ì—´
size = 1000000

# ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¹„êµ
python_list = [0] * size
numpy_array = np.zeros(size)

print(f"Python List Memory: {sys.getsizeof(python_list):,} bytes")
print(f"NumPy Array Memory: {numpy_array.nbytes:,} bytes")
print(f"Memory Efficiency: {sys.getsizeof(python_list) / numpy_array.nbytes:.1f}x")

# ì„±ëŠ¥ ë¹„êµ
def python_sum_squares(lst):
    return sum(x**2 for x in lst)

def numpy_sum_squares(arr):
    return np.sum(arr**2)

# í…ŒìŠ¤íŠ¸ ë°ì´í„°
test_list = list(range(100000))
test_array = np.arange(100000)

# Python ë¦¬ìŠ¤íŠ¸ ì„±ëŠ¥
start = time.time()
python_result = python_sum_squares(test_list)
python_time = time.time() - start

# NumPy ë°°ì—´ ì„±ëŠ¥
start = time.time()
numpy_result = numpy_sum_squares(test_array)
numpy_time = time.time() - start

print(f"\nPerformance Comparison:")
print(f"Python List Time: {python_time:.4f} seconds")
print(f"NumPy Array Time: {numpy_time:.4f} seconds")
print(f"Speed Improvement: {python_time / numpy_time:.1f}x faster")
```

### ì‹¤ë¬´ ì ìš© ì•„ì´ë””ì–´

```python
# 1. ë¡œê·¸ ë°ì´í„° ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜
def simulate_server_logs():
    """ì„œë²„ ë¡œê·¸ ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜"""
    # 24ì‹œê°„ ë™ì•ˆ 1ë¶„ë§ˆë‹¤ ê¸°ë¡ëœ ì‘ë‹µì‹œê°„ (ms)
    hours = np.arange(24)
    response_times = []
    
    for hour in hours:
        # ì—…ë¬´ì‹œê°„(9-18ì‹œ)ì—ëŠ” ì‘ë‹µì‹œê°„ì´ ë†’ì•„ì§
        if 9 <= hour <= 18:
            base_time = 200 + hour * 10
        else:
            base_time = 100
        
        # 60ë¶„ê°„ì˜ ë°ì´í„° (ë…¸ì´ì¦ˆ í¬í•¨)
        hourly_data = np.random.normal(base_time, 30, 60)
        response_times.extend(hourly_data)
    
    return np.array(response_times)

# ë¡œê·¸ ë°ì´í„° ìƒì„± ë° ë¶„ì„
log_data = simulate_server_logs()
time_axis = np.arange(len(log_data)) / 60  # ì‹œê°„ ë‹¨ìœ„ ë³€í™˜

# ì‹œê°í™”
fig, axes = plt.subplots(2, 2, figsize=(16, 10))

# ì „ì²´ ì¶”ì´
axes[0, 0].plot(time_axis, log_data, alpha=0.7, linewidth=0.5)
axes[0, 0].set_title('Server Response Time (24 hours)')
axes[0, 0].set_xlabel('Time (hours)')
axes[0, 0].set_ylabel('Response Time (ms)')
axes[0, 0].grid(True, alpha=0.3)

# íˆìŠ¤í† ê·¸ë¨
axes[0, 1].hist(log_data, bins=50, alpha=0.7, color='skyblue', edgecolor='black')
axes[0, 1].set_title('Response Time Distribution')
axes[0, 1].set_xlabel('Response Time (ms)')
axes[0, 1].set_ylabel('Frequency')
axes[0, 1].grid(True, alpha=0.3)

# ì‹œê°„ëŒ€ë³„ í‰ê· 
hourly_avg = np.array([np.mean(log_data[i*60:(i+1)*60]) for i in range(24)])
axes[1, 0].bar(range(24), hourly_avg, color='lightcoral', alpha=0.7)
axes[1, 0].set_title('Average Response Time by Hour')
axes[1, 0].set_xlabel('Hour of Day')
axes[1, 0].set_ylabel('Avg Response Time (ms)')
axes[1, 0].grid(True, alpha=0.3)

# ì´ë™í‰ê·  (íŠ¸ë Œë“œ ë¶„ì„)
window_size = 60  # 1ì‹œê°„ ìœˆë„ìš°
moving_avg = np.convolve(log_data, np.ones(window_size)/window_size, mode='valid')
axes[1, 1].plot(time_axis[window_size-1:], moving_avg, color='red', linewidth=2)
axes[1, 1].set_title('1-Hour Moving Average')
axes[1, 1].set_xlabel('Time (hours)')
axes[1, 1].set_ylabel('Response Time (ms)')
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# í†µê³„ ë¶„ì„
print("ğŸ“Š Server Performance Analysis:")
print(f"Average Response Time: {np.mean(log_data):.1f} ms")
print(f"95th Percentile: {np.percentile(log_data, 95):.1f} ms")
print(f"Peak Hour: {np.argmax(hourly_avg):02d}:00")
print(f"Best Hour: {np.argmin(hourly_avg):02d}:00")
```

---

## ğŸ¯ ë°°ìš´ ì ê³¼ ë‹¤ìŒ ë‹¨ê³„

### í•µì‹¬ ì¸ì‚¬ì´íŠ¸

1. **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: NumPy ë°°ì—´ì€ Python ë¦¬ìŠ¤íŠ¸ë³´ë‹¤ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ í˜„ì €íˆ ì ìŒ
2. **ì„±ëŠ¥**: ë²¡í„°í™” ì—°ì‚°ìœ¼ë¡œ 10-100ë°° ë¹ ë¥¸ ê³„ì‚° ê°€ëŠ¥
3. **ì‹œê°í™”ì˜ í˜**: ë³µì¡í•œ ìˆ˜í•™ì  ê°œë…ë„ ê·¸ë˜í”„ë¡œ ë³´ë©´ ì§ê´€ì ìœ¼ë¡œ ì´í•´ ê°€ëŠ¥
4. **ì‹¤ë¬´ í™œìš©ì„±**: ì„œë²„ ëª¨ë‹ˆí„°ë§, ë¡œê·¸ ë¶„ì„ ë“± ë°±ì—”ë“œ ì—…ë¬´ì—ë„ ì ìš© ê°€ëŠ¥

### ì–´ë ¤ì› ë˜ ì 

- **ë¸Œë¡œë“œìºìŠ¤íŒ… ê°œë…**: ë‹¤ì°¨ì› ë°°ì—´ ê°„ì˜ ì—°ì‚° ê·œì¹™ ì´í•´
- **ì¸ë±ì‹± ë³µì¡ì„±**: ë‹¤ì°¨ì› ë°°ì—´ì—ì„œì˜ ìŠ¬ë¼ì´ì‹±ê³¼ ë¶ˆë¦° ì¸ë±ì‹±
- **ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ**: View vs Copyì˜ ì°¨ì´ì ê³¼ ì„±ëŠ¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥

### ë‹¤ìŒ í•™ìŠµ ê³„íš

1. **Pandas ë§ˆìŠ¤í„°**: DataFrameì„ í™œìš©í•œ ì‹¤ì œ ë°ì´í„° ë¶„ì„
2. **Scikit-learn ê¸°ì´ˆ**: ë¨¸ì‹ ëŸ¬ë‹ ì•Œê³ ë¦¬ì¦˜ ì ìš©
3. **ìºê¸€ ë„ì „**: ì‹¤ì „ ë°ì´í„° ì‚¬ì´ì–¸ìŠ¤ ê²½í—˜
4. **Deep Learning**: PyTorch/TensorFlowë¡œ ì‹ ê²½ë§ êµ¬í˜„

---

## ğŸ”— ê´€ë ¨ ë§í¬

- **GitHub ì €ì¥ì†Œ**: [numpy-study](https://github.com/hyuk12/numpy-study)
- **Jupyter ë…¸íŠ¸ë¶**: [01_numpy_basics.ipynb](https://github.com/hyuk12/numpy-study/blob/main/notebooks/01_numpy_basics.ipynb)
- **ë‹¤ìŒ í¬ìŠ¤íŒ… ì˜ˆê³ **: "Pandas ì™„ì „ ì •ë³µ: DataFrameìœ¼ë¡œ ì‹¤ì œ ë°ì´í„° ë¶„ì„í•˜ê¸°"

---

## ğŸ’¬ ë§ˆë¬´ë¦¬

AI ë¶€íŠ¸ìº í”„ë¥¼ ì‹œì‘í•˜ë©´ì„œ ì–»ì€ ì¸ì‚¬ì´íŠ¸ê°€ ìºê¸€ì„ í†µí•´ ì‹¤ì œ ì½”ë“œë¥¼ êµ¬ì„±í•˜ê³  ê°ì¢… ëŒ€íšŒë¥¼ ë‚˜ê°€ë©´ì„œ í•™ìŠµ í•˜ëŠ” ê²ƒì´ ì¢‹ì„ ê²ƒ ê°™ì•„ì„œ <br>
NumPy ë¶€í„° Pandas ë“± í•™ìŠµì„ ì§„í–‰í•˜ê³  ìºê¸€ì„ ë„ì „í•´ë³¼ ì˜ˆì •ì…ë‹ˆë‹¤.

ì•„ë¬´ë˜ë„ ìë°” ê¸°ë°˜ì˜ ë°±ì—”ë“œ ì‹¤ë¬´ë¥¼ ê²ªì—ˆì§€ë§Œ, íŒŒì´ì¬ì´ë¼ëŠ” ì–¸ì–´ë¥¼ í†µí•´ í†µê³„ë‚˜ ì‹œê°í™” ìˆ˜ì¹˜ ê³„ì‚°ë“±ì„ í•˜ëŠ” ê²ƒì´ ìµìˆ™í•˜ì§€ëŠ” ì•Šì•„ì„œ ê³„ì† ë³´ë©´ì„œ í•™ìŠµì„ ì´ì–´ë‚˜ê°€ì•¼ í•  ê²ƒ ê°™ìŠµë‹ˆë‹¤.

---

**ì‘ì„±ì¼**: 2025-08-22  
**íƒœê·¸**: `#NumPy` `#Python` `#DataScience` `#MachineLearning` `#ë°±ì—”ë“œê°œë°œì` `#AIì „í–¥` `#ì‹œê°í™”`

*ì´ ê¸€ì´ ë„ì›€ì´ ë˜ì…¨ë‹¤ë©´ ğŸ‘ ê³µê°ê³¼ ëŒ“ê¸€ë¡œ í”¼ë“œë°± ë¶€íƒë“œë¦½ë‹ˆë‹¤!*